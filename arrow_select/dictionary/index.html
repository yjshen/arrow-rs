<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `dictionary` mod in crate `arrow_select`."><title>arrow_select::dictionary - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5ca6ca2a1f83705a.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="arrow_select" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (7120fdac7 2024-07-25)" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../arrow_select/index.html">arrow_select</a><span class="version">52.2.0</span></h2></div><h2 class="location"><a href="#">Module dictionary</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In crate arrow_select</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">arrow_select</a>::<wbr><a class="mod" href="#">dictionary</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/arrow_select/dictionary.rs.html#18-331">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Interner.html" title="struct arrow_select::dictionary::Interner">Interner</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">A best effort interner that maintains a fixed number of buckets
and interns keys based on their hash value</div></li><li><div class="item-name"><a class="struct" href="struct.MergedDictionaries.html" title="struct arrow_select::dictionary::MergedDictionaries">MergedDictionaries</a></div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.bytes_ptr_eq.html" title="fn arrow_select::dictionary::bytes_ptr_eq">bytes_ptr_eq</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Performs a cheap, pointer-based comparison of two byte array</div></li><li><div class="item-name"><a class="fn" href="fn.compute_values_mask.html" title="fn arrow_select::dictionary::compute_values_mask">compute_values_mask</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Return a mask identifying the values that are referenced by keys in <code>dictionary</code>
at the positions indicated by <code>selection</code></div></li><li><div class="item-name"><a class="fn" href="fn.get_masked_values.html" title="fn arrow_select::dictionary::get_masked_values">get_masked_values</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Return a Vec containing for each set index in <code>mask</code>, the index and byte value of that index</div></li><li><div class="item-name"><a class="fn" href="fn.masked_bytes.html" title="fn arrow_select::dictionary::masked_bytes">masked_bytes</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Compute <a href="fn.get_masked_values.html" title="fn arrow_select::dictionary::get_masked_values"><code>get_masked_values</code></a> for a [<code>GenericByteArray</code>]</div></li><li><div class="item-name"><a class="fn" href="fn.merge_dictionary_values.html" title="fn arrow_select::dictionary::merge_dictionary_values">merge_dictionary_values</a></div><div class="desc docblock-short">Given an array of dictionaries and an optional key mask compute a values array
containing referenced values, along with mappings from the [<code>DictionaryArray</code>]
keys to the new keys within this values array. Best-effort will be made to ensure
that the dictionary values are unique</div></li><li><div class="item-name"><a class="fn" href="fn.should_merge_dictionary_values.html" title="fn arrow_select::dictionary::should_merge_dictionary_values">should_merge_dictionary_values</a></div><div class="desc docblock-short">A weak heuristic of whether to merge dictionary values that aims to only
perform the expensive merge computation when it is likely to yield at least
some return over the naive approach used by MutableArrayData</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.PtrEq.html" title="type arrow_select::dictionary::PtrEq">PtrEq</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">A type-erased function that compares two array for pointer equality</div></li></ul></section></div></main></body></html>